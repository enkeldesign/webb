<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Brick Builder – Canvas</title>
<style>
  :root{ color-scheme: light dark; }
  *{ box-sizing: border-box; }
  html,body{ margin:0; height:100%; }
  body{
    font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    background: #0e1320;
    color: #e9ecf1;
    overflow:hidden;
  }
  canvas#game{
    position:fixed; inset:0; display:block; touch-action:manipulation;
    background:
      linear-gradient(#1a2240, #0e1320 60%, #0b0f1a);
  }
  .hud{
    position:fixed; inset:0; pointer-events:none; display:grid;
    grid-template-rows:auto 1fr auto; padding:1rem;
  }
  .hud__top{ display:flex; gap:.75rem; align-items:center; justify-content:space-between; }
  .pill{
    pointer-events:auto;
    background: rgba(255,255,255,.06);
    border:1px solid rgba(255,255,255,.15);
    padding:.5rem .75rem; border-radius:999px; font-weight:600;
    color:#e9ecf1;
  }
  .btn{
    pointer-events:auto; cursor:pointer; user-select:none;
    background: rgba(255,255,255,.08);
    border:1px solid rgba(255,255,255,.25);
    padding:.6rem 1rem; border-radius:.7rem; font-weight:700;
    color:#e9ecf1;
  }
  .btn:focus-visible{ outline:3px solid #4da3ff; outline-offset:2px; }

  .center{
    place-self:center; text-align:center; pointer-events:auto;
    background: rgba(0,0,0,.35);
    border:1px solid rgba(255,255,255,.2);
    padding:1rem 1.25rem; border-radius:1rem; max-width:min(38rem, 90vw);
    box-shadow: 0 10px 40px rgba(0,0,0,.4);
  }
  .title{ font-size:clamp(1.3rem, 2.8vw + .6rem, 2rem); margin:0 0 .25rem; }
  .muted{ opacity:.8; margin:.25rem 0 0; }
  .help{ justify-self:end; align-self:end; opacity:.8; font-size:.9rem; pointer-events:none; }
</style>
</head>
<body>
<canvas id="game" aria-label="Brick Builder game area" role="img"></canvas>

<div class="hud" aria-live="polite">
  <div class="hud__top">
    <div class="pill" id="score">Score: 0</div>
    <button id="restart" class="btn" type="button" aria-keyshortcuts="r">Restart (R)</button>
  </div>

  <div id="overlay" class="center" hidden>
    <h1 class="title" id="stateTitle">Brick Builder</h1>
    <p id="stateMsg" class="muted">Click/tap or press Space/Enter to drop the moving brick. Keep stacking! Overhang is trimmed—miss and it’s game over.</p>
    <div style="margin-top:.75rem; display:flex; gap:.5rem; justify-content:center; flex-wrap:wrap">
      <button id="start" class="btn" type="button" aria-keyshortcuts="Enter Space">Start</button>
      <button id="how" class="btn" type="button">How to play</button>
    </div>
  </div>

  <div class="help muted">Controls: Click / Tap / Space / Enter to drop · R to restart · P to pause</div>
</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha: true });

  // === Viewport-safe sizing ===
  let dpr = 1, W = 0, H = 0;
  function fitCanvas() {
    dpr = Math.max(window.devicePixelRatio || 1, 1);
    const r = canvas.getBoundingClientRect(); // actual on-screen size
    W = Math.max(1, Math.round(r.width));
    H = Math.max(1, Math.round(r.height));
    canvas.width  = Math.round(W * dpr);
    canvas.height = Math.round(H * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
  }
  addEventListener('resize', fitCanvas, { passive: true });
  if (window.visualViewport) {
    // iOS address bar show/hide, pinch-zoom, etc.
    visualViewport.addEventListener('resize', fitCanvas, { passive: true });
    visualViewport.addEventListener('scroll', fitCanvas, { passive: true });
  }
  fitCanvas();

  // === Game constants/state (unchanged except we use W/H) ===
  const G = { gravity:980, moveSpeed:160, fallMax:1200, baseBrickH:24, minOverlap:8, speedupEvery:5, speedupFactor:1.08 };
  const state = { running:false, paused:false, score:0, stack:[], active:null };

  // UI
  const $score = document.getElementById('score');
  const $overlay = document.getElementById('overlay');
  const $start = document.getElementById('start');
  const $how = document.getElementById('how');
  const $restart = document.getElementById('restart');
  const edgeColor = 'rgba(255,255,255,.35)';
  const rivetColor = 'rgba(255,255,255,.55)';
  const groundStroke = 'rgba(255,255,255,.25)';
  const dark = true;
  const colorForLevel = i => `hsl(${(200 + i*9) % 360}, 70%, ${dark?62:54}%)`;

  function showOverlay(t,m,showStart=true){ 
    document.getElementById('stateTitle').textContent=t;
    document.getElementById('stateMsg').textContent=m;
    $start.hidden=!showStart; $overlay.hidden=false;
  }
  function hideOverlay(){ $overlay.hidden=true; }
  function updateScore(n){ state.score+=n; $score.textContent=`Score: ${state.score}`; document.title=`Score ${state.score} – Brick Builder`; }

  function makeBrick(w,x,y,vx=G.moveSpeed){ return {x,y,w,h:G.baseBrickH,vx,vy:0,moving:true,dropping:false,color:colorForLevel(state.stack.length)}; }

  function resetGame(){
    state.running=false; state.paused=false; state.score=0; state.stack.length=0; state.active=null;
    const groundW = Math.min(420, W * 0.8);
    const groundX = W/2;
    const groundY = Math.floor(H * 0.80);
    state.stack.push({ x:groundX, y:groundY, w:groundW, h:G.baseBrickH, color:'hsl(210,10%,40%)', moving:false, dropping:false });
    state.active = makeBrick(groundW, W/2, groundY - G.baseBrickH, G.moveSpeed);
    updateScore(0);
  }

  function dropBrick(){
    if (!state.running || state.paused || !state.active || state.active.dropping) return;
    state.active.moving=false; state.active.dropping=true; state.active.vy=0;
  }

  function startGame(){ hideOverlay(); resetGame(); state.running=true; last=performance.now(); requestAnimationFrame(tick); }
  function gameOver(){ state.running=false; state.active=null; showOverlay('Game Over', `Final score: ${state.score}. Press Start or R to try again.`); }

  addEventListener('keydown', e=>{
    if (e.key===' '||e.key==='Enter'){ e.preventDefault(); dropBrick(); }
    if (e.key.toLowerCase()==='r'){ e.preventDefault(); startGame(); }
    if (e.key.toLowerCase()==='p'){ e.preventDefault(); state.paused=!state.paused; state.paused?showOverlay('Paused','Press P to resume or click Start.',false):(hideOverlay(), last=performance.now(), requestAnimationFrame(tick)); }
  });
  canvas.addEventListener('pointerdown', e=>{ if (e.button===0) dropBrick(); }, { passive:true });
  $start?.addEventListener('click', startGame);
  $restart?.addEventListener('click', startGame);
  $how?.addEventListener('click', ()=> showOverlay('How to play','Drop the sliding brick with click/tap/Space. Only the overlap remains; miss and it’s game over.'));

  // === Loop (now using W/H instead of innerWidth/innerHeight) ===
  let last=0;
  function tick(ts){
    if (!state.running || state.paused) return;
    const dt = Math.min((ts-last)/1000, 1/20); last=ts;
    step(dt); draw(); requestAnimationFrame(tick);
  }

  function step(dt){
    const a = state.active; if (!a) return;
    // patrol
    if (a.moving){
      a.x += a.vx*dt;
      const m=24;
      if (a.x - a.w/2 < m){ a.x = m + a.w/2; a.vx = Math.abs(a.vx); }
      if (a.x + a.w/2 > W - m){ a.x = W - m - a.w/2; a.vx = -Math.abs(a.vx); }
    }
    // drop
    if (a.dropping){
      a.vy = Math.min(a.vy + G.gravity*dt, G.fallMax);
      a.y += a.vy*dt;
      const top = state.stack[state.stack.length-1];
      const hitY = top.y - top.h;
      if (a.y >= hitY){
        const aL=a.x-a.w/2, aR=a.x+a.w/2, tL=top.x-top.w/2, tR=top.x+top.w/2;
        const oL=Math.max(aL,tL), oR=Math.min(aR,tR), overlap=Math.max(0,oR-oL);
        if (overlap < G.minOverlap){ gameOver(); return; }
        a.w = overlap; a.x = oL + overlap/2; a.y = hitY; a.moving=false; a.dropping=false;
        state.stack.push(a); updateScore(1);
        if (state.score % G.speedupEvery === 0) G.moveSpeed *= G.speedupFactor;
        const startFromLeft = (state.stack.length % 2) === 0;
        const nextX = startFromLeft ? (a.w/2 + 24) : (W - a.w/2 - 24);
        state.active = makeBrick(a.w, nextX, a.y - a.h, startFromLeft ? Math.abs(G.moveSpeed) : -Math.abs(G.moveSpeed));

        // keep active near top quarter
        const minTopY = H * 0.25;
        if (state.active.y < minTopY){
          const dy = (minTopY - state.active.y);
          for (const b of state.stack) b.y += dy;
          state.active.y += dy;
        }
      }
    }
  }

  function draw(){
    ctx.clearRect(0,0,W,H);

    // ground reference
    ctx.lineWidth = 1;
    ctx.strokeStyle = groundStroke;
    ctx.beginPath();
    const groundY = (state.stack[0]?.y ?? Math.floor(H*0.8)) + (state.stack[0]?.h ?? 0);
    ctx.moveTo(0, groundY + 0.5);
    ctx.lineTo(W, groundY + 0.5);
    ctx.stroke();

    for (const b of state.stack) drawBrick(b);
    if (state.active) drawBrick(state.active);
  }

  function drawBrick(b){
    // body
    ctx.fillStyle = b.color; roundRect(b.x - b.w/2, b.y, b.w, b.h, 6, true, false);
    // top highlight
    ctx.globalAlpha = .18; ctx.fillStyle = '#fff'; roundRect(b.x - b.w/2 + 3, b.y + 3, b.w - 6, 6, 4, true, false); ctx.globalAlpha = 1;
    // edge
    ctx.lineWidth = 2; ctx.strokeStyle = edgeColor; roundRect(b.x - b.w/2, b.y, b.w, b.h, 6, false, true);
    // rivets
    const n = Math.max(2, Math.floor(b.w / 60)), step = b.w / (n+1);
    ctx.fillStyle = rivetColor;
    for (let i=1;i<=n;i++){ ctx.beginPath(); ctx.arc(b.x - b.w/2 + i*step, b.y + b.h/2, 1.8, 0, Math.PI*2); ctx.fill(); }
  }

  function roundRect(x,y,w,h,r,fill,stroke){
    if (w<1||h<1) return;
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y,   x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x,   y+h, rr);
    ctx.arcTo(x,   y+h, x,   y,   rr);
    ctx.arcTo(x,   y,   x+w, y,   rr);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  // Intro
  showOverlay('Brick Builder', 'Click/tap or press Space/Enter to drop the moving brick. Slice off overhangs; miss and it’s game over.');
})();
</script>
</body>
</html>