<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Archer Chess – Canvas</title>
<style>
  :root {
    color-scheme: light dark;
    /* board */
    --square-light: #e6edf5;
    --square-dark:  #8aa0be;
    --hl-move: rgba(73,211,255,.35);
    --hl-capture: rgba(255,120,120,.45);
    --hl-special: rgba(126,255,179,.35);
    /* chrome */
    --bg: #0e1116;
    --panel: #141922;
    --text: #e7eef7;
  }
  @media (prefers-color-scheme: dark){
    :root{
      --square-light:#2c3442;
      --square-dark:#1f2633;
      --bg:#0b0d12; --panel:#161a21; --text:#e7eef7;
    }
  }
  *{box-sizing:border-box}
  body{
    margin:0; min-height:100dvh; display:grid; place-items:center; padding:24px;
    background: radial-gradient(1200px 800px at 15% -10%, #1e2530 0%, var(--bg) 40%);
    color:var(--text); font-family: ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
  }
  .app{display:grid; gap:16px; grid-template-columns:minmax(320px,min(90vw,720px)); width:100%; max-width:720px}
  .panel{
    background: color-mix(in oklab, var(--panel) 92%, transparent);
    border: 1px solid color-mix(in oklab, var(--panel) 80%, #000 20%);
    border-radius: 16px; padding: 12px 14px;
    box-shadow: 0 10px 30px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.04);
    display:grid; gap:10px
  }
  h1{font-size:1.1rem; margin:0; letter-spacing:.2px}
  .row{display:flex; align-items:center; gap:12px; flex-wrap:wrap}
  .pill{padding:.15rem .5rem; border-radius:999px; background: color-mix(in oklab, var(--panel) 85%, transparent); font-size:.9rem}
  .turn{font-weight:700}
  canvas{
    display:block; width:100%; height:auto; aspect-ratio:1/1; border-radius:18px;
    box-shadow: 0 12px 35px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.06);
    background:#000; /* only seen while loading */
  }
</style>
</head>
<body>
  <div class="app">
    <div class="panel">
      <h1>Archer Chess</h1>
      <div class="row">
        <span class="pill">Click piece → click highlighted target</span>
        <span>Turn: <span id="turn" class="turn">White</span></span>
      </div>
      <canvas id="board" width="800" height="800" aria-label="Archer Chess board"></canvas>
      <div class="pill">Archer = king-move + volley (+3 forward, capture only), merge with rook → immobile Archer Tower (fires forward over pieces), tower can dismount once.</div>
    </div>
  </div>

<script>
/* ====== Archer Chess – Canvas with Checkered Board + SVG Sprites ====== */

const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d', { alpha: true });
const turnEl = document.getElementById('turn');

const S = 8;
const SQ = canvas.width / S;

// Colors (fallbacks guaranteed)
const CSS = getComputedStyle(document.documentElement);
const COLOR = {
  light: CSS.getPropertyValue('--square-light').trim() || '#e6edf5',
  dark:  CSS.getPropertyValue('--square-dark').trim()  || '#8aa0be',
  move:  CSS.getPropertyValue('--hl-move').trim()      || 'rgba(73,211,255,.35)',
  cap:   CSS.getPropertyValue('--hl-capture').trim()   || 'rgba(255,120,120,.45)',
  special:CSS.getPropertyValue('--hl-special').trim()  || 'rgba(126,255,179,.35)',
};

function inside(r,c){ return r>=0 && r<8 && c>=0 && c<8; }
function clone(obj){ return JSON.parse(JSON.stringify(obj)); }

/* ---------- Sprites (SVG data URIs) ---------- */
const SPRITES = {};
function svgURI(svg){ return 'data:image/svg+xml;utf8,' + encodeURIComponent(svg); }
function makeSprite(key, svg){
  const img = new Image(); img.src = svgURI(svg); SPRITES[key] = img; return img;
}

// Shared SVG fragments
const CHIP = (fill, stroke)=>
`<rect x="4" y="4" width="92" height="92" rx="14" ry="14" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>`;
const WCHIP = CHIP('#f8fafc','#cdd5df');
const BCHIP = CHIP('#131822','#2a3240');

// Minimal, consistent icon set (100×100 viewBox). Centered glyphs.
// K,Q,R,N,P + A (Archer) + AT (Archer Tower)
const glyphs = {
  wK: WCHIP + `<path d="M50 23 v8 m-12 7 h24 M30 73 h40 l-3 9 H33z M28 58 a22 18 0 1 0 44 0 a22 18 0 1 0 -44 0z"
                fill="#0b1220" stroke="#0b1220" stroke-width="2"/>`,
  bK: BCHIP + `<path d="M50 23 v8 m-12 7 h24 M30 73 h40 l-3 9 H33z M28 58 a22 18 0 1 0 44 0 a22 18 0 1 0 -44 0z"
                fill="#e7eef7" stroke="#e7eef7" stroke-width="2"/>`,

  wQ: WCHIP + `<path d="M22 42 34 28 46 42 54 28 66 42 78 28 74 60 26 60z" fill="#0b1220"/>
               <rect x="26" y="60" width="48" height="22" rx="3" fill="#0b1220"/>`,
  bQ: BCHIP + `<path d="M22 42 34 28 46 42 54 28 66 42 78 28 74 60 26 60z" fill="#e7eef7"/>
               <rect x="26" y="60" width="48" height="22" rx="3" fill="#e7eef7"/>`,

  wR: WCHIP + `<path d="M28 32 h44 v14 H28zm4 14 h36 v30 H32z" fill="#0b1220"/>`,
  bR: BCHIP + `<path d="M28 32 h44 v14 H28zm4 14 h36 v30 H32z" fill="#e7eef7"/>`,

  wN: WCHIP + `<path d="M68 68 H36 V44 l16-10 8 6 8-4z" fill="#0b1220"/>`,
  bN: BCHIP + `<path d="M68 68 H36 V44 l16-10 8 6 8-4z" fill="#e7eef7"/>`,

  wP: WCHIP + `<circle cx="50" cy="42" r="10" fill="#0b1220"/><rect x="38" y="52" width="24" height="22" rx="4" fill="#0b1220"/>`,
  bP: BCHIP + `<circle cx="50" cy="42" r="10" fill="#e7eef7"/><rect x="38" y="52" width="24" height="22" rx="4" fill="#e7eef7"/>`,

  // Archer: stylized bow + arrow tip (points upward for white, downward for black)
  wA: WCHIP + `<path d="M62 64 C58 46 42 34 30 30" stroke="#0b1220" stroke-width="5" fill="none"/>
               <path d="M30 30 L44 30" stroke="#0b1220" stroke-width="5"/>
               <path d="M50 20 L50 10 M50 10 L46 16 M50 10 L54 16" stroke="#0b1220" stroke-width="4"/>`,
  bA: BCHIP + `<path d="M62 36 C58 54 42 66 30 70" stroke="#e7eef7" stroke-width="5" fill="none"/>
               <path d="M30 70 L44 70" stroke="#e7eef7" stroke-width="5"/>
               <path d="M50 90 L50 100 M50 100 L46 94 M50 100 L54 94" stroke="#e7eef7" stroke-width="4"/>`,

  // Archer Tower: rook body + vertical aiming column
  wAT: WCHIP + `<rect x="34" y="30" width="32" height="40" rx="3" fill="#0b1220"/>
                <rect x="48" y="14" width="4" height="72" rx="2" fill="#14b86a"/>`,
  bAT: BCHIP + `<rect x="34" y="30" width="32" height="40" rx="3" fill="#e7eef7"/>
                <rect x="48" y="14" width="4" height="72" rx="2" fill="#7dffbc"/>`,
};

// Build images
const keys = Object.keys(glyphs);
for(const k of keys) makeSprite(k, `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">${glyphs[k]}</svg>`);

/* ---------- Game State ---------- */
function initialBoard(){
  const e=null, w=t=>({t,c:'w'}), b=t=>({t,c:'b'});
  return [
    [b('R'), b('N'), b('A'), b('Q'), b('K'), b('A'), b('N'), b('R')],
    [b('P'), b('P'), b('P'), b('P'), b('P'), b('P'), b('P'), b('P')],
    [e,e,e,e,e,e,e,e],
    [e,e,e,e,e,e,e,e],
    [e,e,e,e,e,e,e,e],
    [e,e,e,e,e,e,e,e],
    [w('P'), w('P'), w('P'), w('P'), w('P'), w('P'), w('P'), w('P')],
    [w('R'), w('N'), w('A'), w('Q'), w('K'), w('A'), w('N'), w('R')],
  ];
}

const state = {
  board: initialBoard(),
  toMove: 'w',
  selected: null,
  legalTargets: [],
  history: [],
};

function ensureFlags(p){
  if(!p) return;
  if(p.t==='A' && p.canMerge===undefined) p.canMerge = true;
  if(p.t==='AT' && p.canDismount===undefined) p.canDismount = true;
}

/* ---------- Rendering ---------- */
function drawBoard(){
  // Checkered background
  for(let r=0;r<8;r++){
    for(let c=0;c<8;c++){
      ctx.fillStyle = ((r+c)&1) ? COLOR.dark : COLOR.light;
      ctx.fillRect(c*SQ, r*SQ, SQ, SQ);
    }
  }

  // Highlights
  if(state.selected){
    const {r,c} = state.selected;
    ctx.lineWidth = 3;
    ctx.strokeStyle = 'rgba(255,255,255,.6)';
    ctx.strokeRect(c*SQ+2, r*SQ+2, SQ-4, SQ-4);
  }
  for(const t of state.legalTargets){
    const x=t.c*SQ+SQ/2, y=t.r*SQ+SQ/2;
    ctx.fillStyle = t.kind==='cap' ? COLOR.cap : (t.kind==='special' ? COLOR.special : COLOR.move);
    ctx.beginPath(); ctx.arc(x,y,SQ*.18,0,Math.PI*2); ctx.fill();
  }

  // Pieces
  for(let r=0;r<8;r++){
    for(let c=0;c<8;c++){
      const p = state.board[r][c];
      if(p) drawPiece(r,c,p);
    }
  }
}

function spriteKey(p){
  const side = p.c==='w' ? 'w' : 'b';
  if(p.t==='AT') return side+'AT';
  return side + p.t;
}

function drawPiece(r,c,p){
  ensureFlags(p);
  const img = SPRITES[spriteKey(p)];
  if(!img || !img.complete){
    // fallback chip with letter
    ctx.fillStyle = p.c==='w' ? '#f8fafc' : '#131822';
    ctx.strokeStyle = 'rgba(0,0,0,.25)';
    roundRect(c*SQ+6, r*SQ+6, SQ-12, SQ-12, 10, true, false);
    ctx.fillStyle = p.c==='w' ? '#0b1220' : '#e7eef7';
    ctx.font = `700 ${Math.floor(SQ*.34)}px system-ui, sans-serif`;
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(p.t, c*SQ+SQ/2, r*SQ+SQ/2+2);
    return;
  }
  // draw sprite with a soft board shadow
  ctx.save();
  ctx.shadowColor = 'rgba(0,0,0,.35)';
  ctx.shadowBlur = 10;
  ctx.drawImage(img, c*SQ+4, r*SQ+4, SQ-8, SQ-8);
  ctx.restore();
}

function roundRect(x,y,w,h,r,fill,stroke){
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y, x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x, y+h, r);
  ctx.arcTo(x, y+h, x, y, r);
  ctx.arcTo(x, y, x+w, y, r);
  if(fill) ctx.fill(); if(stroke) ctx.stroke();
}

/* ---------- Input ---------- */
canvas.addEventListener('click', (ev)=>{
  const rect = canvas.getBoundingClientRect();
  const c = Math.floor((ev.clientX - rect.left) / SQ);
  const r = Math.floor((ev.clientY - rect.top) / SQ);

  if(state.selected){
    const target = state.legalTargets.find(t=>t.r===r && t.c===c);
    if(target){ target.action(); clearSel(); redraw(); return; }
    const p = state.board[r][c];
    if(p && p.c===state.toMove){ select(r,c); redraw(); return; }
    clearSel(); redraw(); return;
  } else {
    const p = state.board[r][c];
    if(p && p.c===state.toMove){ select(r,c); redraw(); }
  }
});

function clearSel(){ state.selected=null; state.legalTargets=[]; }
function select(r,c){ state.selected={r,c}; state.legalTargets=computeMoves(r,c); }

/* ---------- Move Generation (MVP) ---------- */
function computeMoves(r,c){
  const board = state.board, p = board[r][c]; if(!p) return [];
  ensureFlags(p);
  const me=p.c, opp=me==='w'?'b':'w';
  const out=[];

  function add(rr,cc,kind, action){
    out.push({r:rr,c:cc,kind, action: action || (function(){
      const snap=clone(state); state.history.push(snap);
      const target=board[rr][cc];
      board[rr][cc]=p; board[r][c]=null;
      if(p.t==='A' && target && target.t==='R' && target.c===me){
        board[rr][cc] = {t:'AT', c:me, canDismount:true};
      }
      if(p.t==='P'){ if(me==='w' && rr===0) board[rr][cc]={t:'Q',c:me};
                     if(me==='b' && rr===7) board[rr][cc]={t:'Q',c:me}; }
      state.toMove = opp;
    })});
  }
  function addSpecial(rr,cc, fn){ out.push({r:rr,c:cc,kind:'special', action:fn}); }
  function ray(dr,dc){
    const list=[]; let rr=r+dr, cc=c+dc;
    while(inside(rr,cc)){
      const q=board[rr][cc];
      if(q){ if(q.c!==me) list.push({r:rr,c:cc,cap:true}); break; }
      list.push({r:rr,c:cc}); rr+=dr; cc+=dc;
    }
    return list;
  }

  if(p.t==='P'){
    const dir = me==='w' ? -1 : 1, start = me==='w'?6:1;
    if(inside(r+dir,c) && !board[r+dir][c]) add(r+dir,c,'move');
    if(r===start && !board[r+dir][c] && !board[r+2*dir][c]) add(r+2*dir,c,'move');
    for(const dc of [-1,1]){
      const rr=r+dir, cc=c+dc;
      if(inside(rr,cc)&&board[rr][cc]&&board[rr][cc].c===opp) add(rr,cc,'cap');
    }
  } else if(p.t==='N'){
    for(const [dr,dc] of [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]]){
      const rr=r+dr, cc=c+dc; if(!inside(rr,cc)) continue;
      const q=board[rr][cc]; if(!q) add(rr,cc,'move'); else if(q.c===opp) add(rr,cc,'cap');
    }
  } else if(p.t==='R'){
    for(const [dr,dc] of [[1,0],[-1,0],[0,1],[0,-1]]){
      for(const step of ray(dr,dc)) add(step.r,step.c, step.cap?'cap':'move');
    }
  } else if(p.t==='Q'){
    for(const [dr,dc] of [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]]){
      for(const step of ray(dr,dc)) add(step.r,step.c, step.cap?'cap':'move');
    }
  } else if(p.t==='K'){
    for(let dr=-1;dr<=1;dr++){ for(let dc=-1;dc<=1;dc++){
      if(!dr&&!dc) continue; const rr=r+dr, cc=c+dc; if(!inside(rr,cc)) continue;
      const q=board[rr][cc]; if(!q) add(rr,cc,'move'); else if(q.c===opp) add(rr,cc,'cap');
    }}
  } else if(p.t==='A'){
    // King-like
    for(let dr=-1;dr<=1;dr++){ for(let dc=-1;dc<=1;dc++){
      if(!dr&&!dc) continue; const rr=r+dr, cc=c+dc; if(!inside(rr,cc)) continue;
      const q=board[rr][cc];
      if(q && q.c===me && q.t==='R' && p.canMerge!==false) add(rr,cc,'special'); // merge
      else if(!q) add(rr,cc,'move');
      else if(q.c===opp) add(rr,cc,'cap');
    }}
    // Volley (capture-only) to +3 forward
    const dir = me==='w' ? -1 : 1, vr=r+dir*3, vc=c;
    if(inside(vr,vc) && state.board[vr][vc] && state.board[vr][vc].c===opp){
      addSpecial(vr,vc, function(){
        const snap=clone(state); state.history.push(snap);
        state.board[vr][vc]=null; state.toMove = opp; // Archer stays
      });
    }
  } else if(p.t==='AT'){
    // Fire forward anywhere (capture only), ignoring blockers
    const dir = me==='w' ? -1 : 1;
    for(let rr=r+dir; rr>=0 && rr<8; rr+=dir){
      const q=state.board[rr][c];
      if(q && q.c===opp){
        addSpecial(rr,c, function(){
          const snap=clone(state); state.history.push(snap);
          state.board[rr][c]=null; state.toMove = opp;
        });
      }
    }
    // Dismount once: spawn Archer to any adjacent empty square; rook remains
    if(p.canDismount){
      for(let dr=-1;dr<=1;dr++){ for(let dc=-1;dc<=1;dc++){
        if(!dr&&!dc) continue; const rr=r+dr, cc=c+dc; if(!inside(rr,cc)) continue;
        if(!state.board[rr][cc]){
          addSpecial(rr,cc, function(){
            const snap=clone(state); state.history.push(snap);
            state.board[r][c]={t:'R',c:me};
            state.board[rr][cc]={t:'A',c:me,canMerge:false};
            state.toMove = opp;
          });
        }
      }}
    }
  }
  return out;
}

/* ---------- Boot / Redraw ---------- */
function redraw(){
  drawBoard();
  turnEl.textContent = state.toMove==='w' ? 'White' : 'Black';
}
(function reset(){
  state.board = initialBoard();
  state.toMove = 'w';
  state.selected = null;
  state.legalTargets = [];
  state.history = [];
  redraw();
})();

// Expose for console tweaks
window._archerChess = { state, redraw };
</script>
</body>
</html>