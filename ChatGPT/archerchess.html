<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Archer Chess – Web Sprites</title>
<style>
  :root{
    color-scheme: light dark;
    --light:#e6edf5; --dark:#8aa0be;
    --light-d:#2c3442; --dark-d:#1f2633;
    --hl-move: rgba(73,211,255,.35);
    --hl-cap: rgba(255,120,120,.45);
    --hl-spec: rgba(126,255,179,.35);
  }
  @media (prefers-color-scheme: dark){
    :root{ --light:var(--light-d); --dark:var(--dark-d); }
  }
  body{margin:0; display:grid; place-items:center; min-height:100dvh; background:#0b0d12; font-family:system-ui,Segoe UI,Arial,sans-serif; color:#e7eef7; padding:20px}
  .wrap{max-width:720px; width:min(92vw,720px)}
  canvas{width:100%; height:auto; aspect-ratio:1/1; border-radius:16px; box-shadow:0 12px 35px rgba(0,0,0,.35); touch-action:manipulation}
  .row{display:flex; justify-content:space-between; align-items:center; margin:8px 0}
</style>
</head>
<body>
<div class="wrap">
  <div class="row"><strong>Archer Chess</strong><span>Turn: <span id="turn">White</span></span></div>
  <canvas id="board" aria-label="Archer Chess board"></canvas>
  <p style="opacity:.8">Archer: king-move + volley (+3 forward capture). Merge with rook → Tower (immobile, fires forward over pieces). Tower can dismount once.</p>
</div>

<script>
/* --- Configure web-hosted sprite URLs --- */
/* Cburnett/Wikipedia set for standard pieces (PNG, 60px) */
const WIKI = "https://upload.wikimedia.org/wikipedia/commons";
const SPRITE_URLS = {
  wK: `${WIKI}/3/3b/Chess_klt60.png`,
  bK: `${WIKI}/e/e3/Chess_kdt60.png`,
  wQ: `${WIKI}/4/49/Chess_qlt60.png`,
  bQ: `${WIKI}/a/af/Chess_qdt60.png`,
  wR: `${WIKI}/5/5c/Chess_rlt60.png`,
  bR: `${WIKI}/a/a0/Chess_rdt60.png`,
  wN: `${WIKI}/2/28/Chess_nlt60.png`,
  bN: `${WIKI}/f/f1/Chess_ndt60.png`,
  wP: `https://images.chesscomfiles.com/chess-themes/pieces/classic/150/wp.png`,
  bP: `https://images.chesscomfiles.com/chess-themes/pieces/classic/150/bp.png`,

  /* TODO: point these to your hosted Archer/Tower SVG/PNGs */
  wA: `https://enkel.design/ChatGPT/IMG_5740.jpeg`,
  bA: `https://enkel.design/ChatGPT/IMG_5739.jpeg`,
  wAT:`https://enkel.design/ChatGPT/IMG_5738.jpeg`,
  bAT:`https://enkel.design/ChatGPT/IMG_5737.jpeg`,
};

/* ====== Canvas + HiDPI ====== */
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d', { alpha:true });
const turnEl = document.getElementById('turn');
let SQ = 100;

function resize(){
  const dpr = devicePixelRatio || 1;
  const w = canvas.getBoundingClientRect().width || 600;
  canvas.width = Math.round(w*dpr);
  canvas.height = Math.round(w*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
  SQ = w/8;
  draw();
}
new ResizeObserver(resize).observe(canvas);

/* ====== Load sprites ====== */
const IMGS = {};
function loadAll(urls){
  return Promise.all(Object.entries(urls).map(([k,src])=>new Promise(res=>{
    const img = new Image(); img.crossOrigin = "anonymous";
    img.onload = ()=>{ IMGS[k]=img; res(); };
    img.onerror = ()=>{ IMGS[k]=null; res(); };
    img.src = src;
  })));
}

/* ====== Game state & rules (same Archer logic) ====== */
function initBoard(){
  const e=null, w=t=>({t,c:'w'}), b=t=>({t,c:'b'});
  return [
    [b('R'), b('N'), b('A'), b('Q'), b('K'), b('A'), b('N'), b('R')],
    [b('P'), b('P'), b('P'), b('P'), b('P'), b('P'), b('P'), b('P')],
    [e,e,e,e,e,e,e,e],
    [e,e,e,e,e,e,e,e],
    [e,e,e,e,e,e,e,e],
    [e,e,e,e,e,e,e,e],
    [w('P'), w('P'), w('P'), w('P'), w('P'), w('P'), w('P'), w('P')],
    [w('R'), w('N'), w('A'), w('Q'), w('K'), w('A'), w('N'), w('R')],
  ];
}
const state = { board:initBoard(), toMove:'w', selected:null, legal:[], history:[] };
function inside(r,c){ return r>=0 && r<8 && c>=0 && c<8; }
function ensureFlags(p){ if(!p) return; if(p.t==='A'&&p.canMerge===undefined)p.canMerge=true; if(p.t==='AT'&&p.canDismount===undefined)p.canDismount=true; }

/* ====== Rendering ====== */
function draw(){
  // board
  const light = getComputedStyle(document.documentElement).getPropertyValue('--light').trim() || '#e6edf5';
  const dark  = getComputedStyle(document.documentElement).getPropertyValue('--dark').trim()  || '#8aa0be';
  for(let r=0;r<8;r++)for(let c=0;c<8;c++){
    ctx.fillStyle = ((r+c)&1)?dark:light;
    ctx.fillRect(c*SQ, r*SQ, SQ, SQ);
  }
  // highlights
  const mv = getComputedStyle(document.documentElement).getPropertyValue('--hl-move').trim() || 'rgba(73,211,255,.35)';
  const cp = getComputedStyle(document.documentElement).getPropertyValue('--hl-cap').trim()  || 'rgba(255,120,120,.45)';
  const sp = getComputedStyle(document.documentElement).getPropertyValue('--hl-spec').trim() || 'rgba(126,255,179,.35)';
  if(state.selected){
    const {r,c}=state.selected; ctx.lineWidth=3; ctx.strokeStyle='rgba(255,255,255,.65)';
    ctx.strokeRect(c*SQ+2, r*SQ+2, SQ-4, SQ-4);
  }
  for(const t of state.legal){
    ctx.fillStyle = t.kind==='cap'?cp:(t.kind==='special'?sp:mv);
    ctx.beginPath(); ctx.arc(t.c*SQ+SQ/2, t.r*SQ+SQ/2, SQ*.18, 0, Math.PI*2); ctx.fill();
  }
  // pieces
  for(let r=0;r<8;r++) for(let c=0;c<8;c++){
    const p = state.board[r][c]; if(!p) continue;
    const key = (p.c==='w'?'w':'b') + (p.t==='AT'?'AT':p.t);
    const img = IMGS[key];
    if(img){
      ctx.drawImage(img, c*SQ+4, r*SQ+4, SQ-8, SQ-8);
    }else{
      // fallback letter
      ctx.fillStyle = p.c==='w' ? '#f8fafc' : '#131822';
      ctx.fillRect(c*SQ+6, r*SQ+6, SQ-12, SQ-12);
      ctx.fillStyle = p.c==='w' ? '#0b1220' : '#e7eef7';
      ctx.font = `700 ${Math.floor(SQ*.34)}px system-ui`; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(p.t, c*SQ+SQ/2, r*SQ+SQ/2+2);
    }
  }
}

function select(r,c){ state.selected={r,c}; state.legal = genMoves(r,c); }
function clearSel(){ state.selected=null; state.legal=[]; }
canvas.addEventListener('pointerdown', (ev)=>{
  const rect = canvas.getBoundingClientRect();
  const x = ev.clientX - rect.left, y = ev.clientY - rect.top;
  const c = Math.floor(x/rect.width*8), r = Math.floor(y/rect.height*8);
  if(state.selected){
    const tgt = state.legal.find(t=>t.r===r && t.c===c);
    if(tgt){ tgt.action(); clearSel(); turnEl.textContent = state.toMove==='w'?'White':'Black'; draw(); return; }
    const q = state.board[r][c];
    if(q && q.c===state.toMove){ select(r,c); draw(); return; }
    clearSel(); draw(); return;
  } else {
    const p = state.board[r][c];
    if(p && p.c===state.toMove){ select(r,c); draw(); }
  }
});

/* ====== Move gen (MVP, no check) ====== */
function clone(o){ return JSON.parse(JSON.stringify(o)); }
function genMoves(r,c){
  const B=state.board, P=B[r][c]; if(!P) return []; ensureFlags(P);
  const me=P.c, opp=me==='w'?'b':'w', out=[];
  function add(rr,cc,kind,fn){
    out.push({r:rr,c:cc,kind, action: fn || (function(){
      const snap=clone(state); state.history.push(snap);
      const target=B[rr][cc]; B[rr][cc]=P; B[r][c]=null;
      if(P.t==='A' && target && target.t==='R' && target.c===me){ B[rr][cc]={t:'AT',c:me,canDismount:true}; }
      if(P.t==='P'){ if(me==='w'&&rr===0) B[rr][cc]={t:'Q',c:me}; if(me==='b'&&rr===7) B[rr][cc]={t:'Q',c:me}; }
      state.toMove = opp;
    })});
  }
  function addSpec(rr,cc,fn){ out.push({r:rr,c:cc,kind:'special',action:fn}); }
  function ray(dr,dc){
    const L=[]; let rr=r+dr, cc=c+dc;
    while(inside(rr,cc)){
      const q=B[rr][cc];
      if(q){ if(q.c!==me) L.push({r:rr,c:cc,cap:true}); break; }
      L.push({r:rr,c:cc}); rr+=dr; cc+=dc;
    } return L;
  }

  if(P.t==='P'){
    const dir=me==='w'?-1:1, start=me==='w'?6:1;
    if(inside(r+dir,c) && !B[r+dir][c]) add(r+dir,c,'move');
    if(r===start && !B[r+dir][c] && !B[r+2*dir][c]) add(r+2*dir,c,'move');
    for(const dc of [-1,1]){ const rr=r+dir, cc=c+dc; if(inside(rr,cc)&&B[rr][cc]?.c===opp) add(rr,cc,'cap'); }
  } else if(P.t==='N'){
    for(const [dr,dc] of [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]]){
      const rr=r+dr, cc=c+dc; if(!inside(rr,cc)) continue;
      const q=B[rr][cc]; if(!q) add(rr,cc,'move'); else if(q.c===opp) add(rr,cc,'cap');
    }
  } else if(P.t==='R'){
    for(const d of [[1,0],[-1,0],[0,1],[0,-1]]) for(const s of ray(...d)) add(s.r,s.c, s.cap?'cap':'move');
  } else if(P.t==='Q'){
    for(const d of [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]]) for(const s of ray(...d)) add(s.r,s.c, s.cap?'cap':'move');
  } else if(P.t==='K'){
    for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){
      if(!dr&&!dc) continue; const rr=r+dr, cc=c+dc; if(!inside(rr,cc)) continue;
      const q=B[rr][cc]; if(!q) add(rr,cc,'move'); else if(q.c===opp) add(rr,cc,'cap');
    }
  } else if(P.t==='A'){
    // king-like + merge
    for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){
      if(!dr&&!dc) continue; const rr=r+dr, cc=c+dc; if(!inside(rr,cc)) continue;
      const q=B[rr][cc];
      if(q && q.c===me && q.t==='R' && P.canMerge!==false) add(rr,cc,'special'); // merge
      else if(!q) add(rr,cc,'move');
      else if(q.c===opp) add(rr,cc,'cap');
    }
    // volley: +3 forward capture only
    const dir=me==='w'?-1:1, vr=r+dir*3, vc=c;
    if(inside(vr,vc) && B[vr][vc]?.c===opp){
      addSpec(vr,vc, function(){
        const snap=clone(state); state.history.push(snap);
        B[vr][vc]=null; state.toMove=opp; // Archer stays put
      });
    }
  } else if(P.t==='AT'){
    // fire forward capture, ignoring blockers
    const dir=me==='w'?-1:1;
    for(let rr=r+dir; rr>=0 && rr<8; rr+=dir){
      const q=B[rr][c];
      if(q && q.c===opp){
        addSpec(rr,c, function(){
          const snap=clone(state); state.history.push(snap);
          B[rr][c]=null; state.toMove=opp;
        });
      }
    }
    // dismount once
    if(P.canDismount){
      for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){
        if(!dr&&!dc) continue; const rr=r+dr, cc=c+dc; if(!inside(rr,cc)) continue;
        if(!B[rr][cc]){
          addSpec(rr,cc, function(){
            const snap=clone(state); state.history.push(snap);
            B[r][c]={t:'R',c:me};
            B[rr][cc]={t:'A',c:me,canMerge:false};
            state.toMove=opp;
          });
        }
      }
    }
  }
  return out;
}

/* ====== Boot ====== */
loadAll(SPRITE_URLS).then(()=>{ resize(); turnEl.textContent='White'; });
</script>
</body>
</html>